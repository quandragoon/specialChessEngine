I. Profiling data from starter code, obtained with a single “go depth 6” input:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total    
 time   seconds   seconds    calls   s/call   s/call  name    
 32.80      0.61     0.61     3716     0.00     0.00  scout_search_student
 15.60      0.90     0.29  2825303     0.00     0.00  make_move
 15.60      1.19     0.29   575038     0.00     0.00  h_squares_attackable
 12.37      1.42     0.23   575038     0.00     0.00  mobility
  5.11      1.52     0.10 129958716     0.00     0.00  square_of
  4.84      1.61     0.09   287519     0.00     0.00  eval
  3.50      1.67     0.07        1     0.07     0.07  init_zob
  2.15      1.71     0.04 20031492     0.00     0.00  color_of
  1.61      1.74     0.03   319478     0.00     0.00  tt_hashtable_get
  1.61      1.77     0.03   120784     0.00     0.00  generate_all
  0.81      1.79     0.02 16164362     0.00     0.00  fil_of
  0.81      1.80     0.02 16119914     0.00     0.00  rnk_of
  0.54      1.81     0.01 29983744     0.00     0.00  ptype_of
  0.54      1.82     0.01 10051808     0.00     0.00  ori_of
  0.54      1.83     0.01  1356286     0.00     0.00  reflect_of
  0.54      1.84     0.01   575038     0.00     0.00  kaggressive
  0.54      1.85     0.01                             set_color
  0.27      1.86     0.01  2300152     0.00     0.00  opp_color
  0.27      1.86     0.01   456384     0.00     0.00  color_to_move_of
  0.00      1.86     0.00  8956948     0.00     0.00  beam_of
  0.00      1.86     0.00  6970408     0.00     0.00  from_square
  0.00      1.86     0.00  6970408     0.00     0.00  ptype_mv_of
  0.00      1.86     0.00  6970408     0.00     0.00  rot_of
  0.00      1.86     0.00  6970408     0.00     0.00  to_square
  0.00      1.86     0.00  4600304     0.00     0.00  dir_of
  0.00      1.86     0.00   363309     0.00     0.00  update_best_move_history
  0.00      1.86     0.00   120783     0.00     0.00  tt_adjust_score_for_hashtable
  0.00      1.86     0.00   120783     0.00     0.00  tt_hashtable_put
  0.00      1.86     0.00    42732     0.00     0.00  tt_is_usable
  0.00      1.86     0.00    31959     0.00     0.00  tt_adjust_score_from_hashtable
  0.00      1.86     0.00    10898     0.00     0.00  tt_move_of
  0.00      1.86     0.00     8260     0.00     0.00  myrand

-----------------------------------------------------------------------------------------------------
II. Changes so far:

A. James: 

1. piece_t has been changed from an int to a uint8_t (a type four times smaller). Since position_t contains a board of 16*16 = 256 piece_t’s, this reduces the size of position_t considerably, which speeds up functions throughout move_gen.c and elsewhere since all code that assigns one position_t to another now needs to copy far less data. The only challenge in making this change was recognizing that -1 was previousy stored in a piece_t as a sentinel value to indicate that the KO rule had been violated. A uint8_t cannot store -1, so this does not work with the new representation. We changed the sentinel value to a positive value larger than the largest valid piece value and the problem was solved.

Profiling data on the change:

“current” is a player that includes this change. “reference” is different from “current” only in that it doesn’t include this change. Note that “current” wins more games in all three trials.

Trial 1
Rank Name        Elo    +    - games score oppo. draws 
   1 reference     0  146  188    20   38%     0    5% 
   2 current       0  188  146    20   63%     0    5% 

Trial 2
Rank Name        Elo    +    - games score oppo. draws 
   1 reference     0  155  163    20   48%     0    5% 
   2 current       0  163  155    20   53%     0    5% 
 
Trial 3
Rank Name        Elo    +    - games score oppo. draws 
   1 reference     0  149  174    20   43%     0    5% 
   2 current       0  174  149    20   58%     0    5%

2*. Attempted to switch to a 8x8 board with a function to check if a calculated board position is out of bounds. Had some bugs, and some profiling indicated that the change would not improve performance significantly or at all. 

**************************************************
B. Deepak:

1. Moved the procedure that sorts the sortable move list from inside the big for loop within the main scout_search function outside, so that the same work is not needlessly repeatedly at every iteration (since all sort operations past the first one are trying to sort an already sorted list).

2. Another pretty neat optimization that we optimized within the scout search function was borne from the fact that not every move in the list of moves generated by the generate_all method is associated with a sort_key. We used a linear time algorithm to move over all moves with no hash key to the right side of the list of moves, and only try to sort the moves on the left side of the list, which we know has hash keys.

lauto version 1.0
Testing player: current
Testing player: reference
PGN file ../tests/compare.pgn not found.  Keep going.

Use opening book specified: ../tests/book.dta
         1.0 sec           0.000 gpm         2 games
        21.7 sec          22.040 gpm        10 games
        42.5 sec          22.569 gpm        18 games
        47.3 sec          22.797 gpm        20 games
Finished ...

  anchor: nobody
     elo: 3000

Rank Name        Elo    +    - games score oppo. draws
   1 reference     0  149  174    20   43%     0    5%
   2 current       0  174  149    20   58%     0    5%

lauto version 1.0
Testing player: current
Testing player: reference
PGN file ../tests/compare.pgn not found.  Keep going.

Use opening book specified: ../tests/book.dta
         1.0 sec           0.000 gpm         2 games
        21.7 sec          22.042 gpm        10 games
        42.5 sec          22.568 gpm        18 games
        47.2 sec          22.860 gpm        20 games
Finished ...

  anchor: nobody
     elo: 3000

Rank Name        Elo    +    - games score oppo. draws
   1 reference     0  155  163    20   48%     0    5%
   2 current       0  163  155    20   53%     0    5%

3. Other quick optimizations included created a lookup table for the h_dist function in eval.c.

4*. We also tried making the fire function more fast by using bit array representations for the rows and columns of the board and using bit hacks to determine the piece a laser beam hits next much more efficiently than the linear time walk-through being done in the reference code. However, we have not been able to see any speedup with this approach so far, however we believe that with some augmentation this method will give us better gains.

**************************************************
C. Quan:

1. Optimized hashtable_resize in tt.c. Using bithack to round up to the nearest upper power of 2, i.e. 8 becomes 16, 16 becomes 32, etc.

2*. Implemented a “piece to position” mapping in position_t. I used an array of “Piece” to store all the pieces, where Piece has the type, color, rank, file, and square of the piece. The assumption here is that there are a lot more empty squares than squares with pieces, so iterating over the pieces would be much faster than over the squares on the board. Also, according to the profile, functions like square_of(), rnk_of(), and fil_of() are called very frequently. The frequency at which these attributes change is much lower than of those function calls. Therefore, by pre-computing these attributes, I figured we could get some gain in speed. However, the result is the total opposite of what I expected. The code slowed down severely for some unknown reason. I will investigate this in the future.

3. Combined functions in eval such as kface and kaggressive. These two functions compute the same variables and combining them cuts the amount of these computations in half. 

4. In the eval loop, many variables computed in each iteration are also used in the functions called within the iteration. Therefore, I passed these variables to those functions to avoid redundant computations.

5. Optimized logic blocks and made other small optimizations in eval.c.

With optimizations 3, 4, and 5 (timed run of a single execution of “go depth 7”):

Before:
real  0m5.466s
user  0m5.432s
sys 0m0.016s

After:
real  0m5.309s
user  0m5.288s
sys 0m0.008s

**************************************************
D. Varun:

1. Restructured the function h_squares_attackable in eval.c so as to no longer use the unnecessary laser_map array. The old function iterated through all squares on the board after the squares which were traversed by the laser were recorded in the laser_map. Instead, the new version preserves the original functionality by simply just adding up harmonic distances to the opposing king as it follows the path of the beam from the reference king. This eliminates the extra memory overhead and looping over the full board. Since it was strictly better both in terms of space and time complexity, it gave us fairly good gains (decreased the time it took to traverse a fixed depth).

After making the optimization and running a comparison between the two versions (before and after the change corresponding to number 1):

lauto version 1.0
Testing player: current
Testing player: reference
PGN file ../tests/compare.pgn not found.  Keep going.

Use opening book specified: ../tests/book.dta
         1.0 sec           0.000 gpm         2 games
        21.7 sec          22.040 gpm        10 games
        42.5 sec          25.390 gpm        20 games
        45.6 sec          23.683 gpm        20 games
Finished ...

  anchor: nobody
     elo: 3000

Rank Name        Elo    +    - games score oppo. draws 
   1 reference     0  144  243    20   28%     0    5% 
   2 current       0  243  144    20   73%     0    5% 

lauto version 1.0
Testing player: current
Testing player: reference
PGN file ../tests/compare.pgn not found.  Keep going.

Use opening book specified: ../tests/book.dta
         1.0 sec           0.000 gpm         2 games
        21.7 sec          22.042 gpm        10 games
        42.5 sec          23.981 gpm        19 games
        45.1 sec          23.907 gpm        20 games
Finished ...

  anchor: nobody
     elo: 3000

Rank Name        Elo    +    - games score oppo. draws 
   1 reference     0  130  191    20   30%     0   20% 
   2 current       0  191  130    20   70%     0   20% 

lauto version 1.0
Testing player: current
Testing player: reference
PGN file ../tests/compare.pgn not found.  Keep going.

Use opening book specified: ../tests/book.dta
         1.0 sec           0.000 gpm         2 games
        21.7 sec          22.041 gpm        10 games
        42.5 sec          25.391 gpm        20 games
        47.3 sec          22.808 gpm        20 games
Finished ...

  anchor: nobody
     elo: 3000

Rank Name        Elo    +    - games score oppo. draws 
   1 reference     0  146  188    20   38%     0    5% 
   2 current       0  188  146    20   63%     0    5%

Using time based comparison (go depth 7):

Before:
real  0m3.295s
user  0m3.272s
sys 0m0.016s

After:
real  0m3.682s
user  0m3.656s
sys 0m0.016s


2. Inlined the hottest functions (by number of calls). These included square_of, rnk_of, fil_of, ptype_of, color_of, etc. This gave us great gains as many of these functions were around 2-3 arithmetic operations/bit shifts; reducing the function call overhead improved the run time greatly.

3. Some quick optimizations like creating look-up tables for rnk_of and fil_of after we reduced the size of the array to 10 x 10 from 16 x 16. This gave us marginal, but still positive gains.

4*. In a fashion similar the first optimization, the mobility function in eval.c could be optimized to avoid the laser_map function overhead and more cleverly compute the mobility of the opposing king at some position by using a global array that was only initialized once. In theory, this seemed to be both faster and space efficient and should have given us gains; however, the results we saw were too noisy to determine anything conclusively so we left it out.

-----------------------------------------------------------------------------------------------------
III. Planned optimizations:

Profiling after Beta I submitted (obtained with a single “go depth 6” input):
Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total    
 time   seconds   seconds    calls  ms/call  ms/call  name    
 38.24      0.26     0.26   334307     0.00     0.00  eval
 14.71      0.36     0.10   668614     0.00     0.00  mobility
 14.71      0.46     0.10     2870     0.03     0.24  scout_search_reference
 10.30      0.53     0.07  2642717     0.00     0.00  make_move
  7.35      0.58     0.05   101629     0.00     0.00  generate_all
  5.88      0.62     0.04   668614     0.00     0.00  h_squares_attackable
  4.41      0.65     0.03   356411     0.00     0.00  tt_hashtable_get
  2.21      0.67     0.02 10697824     0.00     0.00  dir_of
  1.47      0.68     0.01  6246198     0.00     0.00  ptype_mv_of
  0.74      0.68     0.01  9850516     0.00     0.00  beam_of
  0.00      0.68     0.00  9768148     0.00     0.00  ori_of
  0.00      0.68     0.00  6246198     0.00     0.00  from_square
  0.00      0.68     0.00  6246198     0.00     0.00  rot_of
  0.00      0.68     0.00  6246198     0.00     0.00  to_square
  0.00      0.68     0.00  2674456     0.00     0.00  opp_color
  0.00      0.68     0.00  1516108     0.00     0.00  reflect_of
  0.00      0.68     0.00   477312     0.00     0.00  color_to_move_of
  0.00      0.68     0.00   101627     0.00     0.00  tt_adjust_score_for_hashtable
  0.00      0.68     0.00   101627     0.00     0.00  tt_hashtable_put
  0.00      0.68     0.00    31270     0.00     0.00  tt_is_usable
  0.00      0.68     0.00    22104     0.00     0.00  tt_adjust_score_from_hashtable
  0.00      0.68     0.00     9267     0.00     0.00  tt_move_of

Our plan for the second beta is to first work on the changes that we started for Beta I but were unable to completely finish (the changes listed with a ‘*’ in the previous section). Next, we plan to carefully examine some of the hottest functions listed in the above profiling output to see if we can find any additional optimizations. We will look at functions in order of their appearance in the above profiling output.

Finally, we will try to make some improvements to the parallelization code.

-----------------------------------------------------------------------------------------------------
IV. Planned breakdown of work:

Each team member will work on his respective incomplete Beta I changes (i.e. the changes with a ‘*’ in his section).

With respect the hot functions in the profiling output in the previous section, James will focus on changes to move_gen.c, Deepak on changes to search.c, and Quan and Varun on changes to tt.c and eval.c.

Each of us will look for parallelization potential in our respective files.

